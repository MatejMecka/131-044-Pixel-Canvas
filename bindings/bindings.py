# This file was generated by stellar_contract_bindings v0.5.0b0 and stellar_sdk v13.1.0.

from __future__ import annotations

from enum import IntEnum, Enum
from typing import Dict, List, Tuple, Optional, Union

from stellar_sdk import scval, xdr, Address, MuxedAccount, Keypair
from stellar_sdk.contract import AssembledTransaction, ContractClient
from stellar_sdk.contract import AssembledTransactionAsync, ContractClientAsync

NULL_ACCOUNT = "GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWHF"


class DataKeyKind(Enum):
    Canvas = "Canvas"
    Admin = "Admin"


class DataKey:
    def __init__(
        self,
        kind: DataKeyKind,
    ):
        self.kind = kind

    def to_scval(self) -> xdr.SCVal:
        if self.kind == DataKeyKind.Canvas:
            return scval.to_enum(self.kind.name, None)
        if self.kind == DataKeyKind.Admin:
            return scval.to_enum(self.kind.name, None)
        raise ValueError(f"Invalid kind: {self.kind}")

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_enum(val)
        kind = DataKeyKind(elements[0])
        if kind == DataKeyKind.Canvas:
            return cls(kind)
        if kind == DataKeyKind.Admin:
            return cls(kind)
        raise ValueError(f"Invalid kind: {kind}")

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, DataKey):
            return NotImplemented
        if self.kind != other.kind:
            return False
        return True

    def __hash__(self) -> int:
        return hash(self.kind)


class PixelInfo:
    colour: int
    x: int
    y: int

    def __init__(self, colour: int, x: int, y: int):
        self.colour = colour
        self.x = x
        self.y = y

    def to_scval(self) -> xdr.SCVal:
        return scval.to_struct(
            {
                "colour": scval.to_uint32(self.colour),
                "x": scval.to_uint32(self.x),
                "y": scval.to_uint32(self.y),
            }
        )

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        elements = scval.from_struct(val)
        return cls(
            scval.from_uint32(elements["colour"]),
            scval.from_uint32(elements["x"]),
            scval.from_uint32(elements["y"]),
        )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, PixelInfo):
            return NotImplemented
        return self.colour == other.colour and self.x == other.x and self.y == other.y

    def __hash__(self) -> int:
        return hash((self.colour, self.x, self.y))


class Error(IntEnum):
    NegativeValue = 1
    OverflowValue = 2
    LowBalance = 3
    InvalidColor = 4
    EntryExists = 5
    InvalidPixelCount = 6
    TooManyPixels = 7
    NotInitialized = 8
    NotAdmin = 9

    def to_scval(self) -> xdr.SCVal:
        return scval.to_uint32(self.value)

    @classmethod
    def from_scval(cls, val: xdr.SCVal):
        return cls(scval.from_uint32(val))


class Client(ContractClient):
    def init(
        self,
        admin: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[None]:
        return self.invoke(
            "init",
            [scval.to_address(admin)],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def extend_init(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "extend_init",
            [],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def place(
        self,
        user: Union[Address, str],
        x: int,
        y: int,
        colour: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "place",
            [
                scval.to_address(user),
                scval.to_uint32(x),
                scval.to_uint32(y),
                scval.to_uint32(colour),
            ],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def place_multiple(
        self,
        user: Union[Address, str],
        pixels: List[PixelInfo],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bool]:
        return self.invoke(
            "place_multiple",
            [scval.to_address(user), scval.to_vec([e.to_scval() for e in pixels])],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def get_pixel(
        self,
        x: int,
        y: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[int]:
        return self.invoke(
            "get_pixel",
            [scval.to_uint32(x), scval.to_uint32(y)],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def get_canvas(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[bytes]:
        return self.invoke(
            "get_canvas",
            [],
            parse_result_xdr_fn=lambda v: scval.from_bytes(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def get_pixels(
        self,
        coords: List[Tuple[int, int]],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[List[int]]:
        return self.invoke(
            "get_pixels",
            [
                scval.to_vec(
                    [
                        scval.to_tuple_struct(
                            [scval.to_uint32(e[0]), scval.to_uint32(e[1])]
                        )
                        for e in coords
                    ]
                )
            ],
            parse_result_xdr_fn=lambda v: [
                scval.from_uint32(e) for e in scval.from_vec(v)
            ],
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    def hello(
        self,
        to: bytes,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransaction[List[bytes]]:
        return self.invoke(
            "hello",
            [scval.to_string(to)],
            parse_result_xdr_fn=lambda v: [
                scval.from_string(e) for e in scval.from_vec(v)
            ],
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )


class ClientAsync(ContractClientAsync):
    async def init(
        self,
        admin: Union[Address, str],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[None]:
        return await self.invoke(
            "init",
            [scval.to_address(admin)],
            parse_result_xdr_fn=lambda _: None,
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def extend_init(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "extend_init",
            [],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def place(
        self,
        user: Union[Address, str],
        x: int,
        y: int,
        colour: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "place",
            [
                scval.to_address(user),
                scval.to_uint32(x),
                scval.to_uint32(y),
                scval.to_uint32(colour),
            ],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def place_multiple(
        self,
        user: Union[Address, str],
        pixels: List[PixelInfo],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bool]:
        return await self.invoke(
            "place_multiple",
            [scval.to_address(user), scval.to_vec([e.to_scval() for e in pixels])],
            parse_result_xdr_fn=lambda v: scval.from_bool(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def get_pixel(
        self,
        x: int,
        y: int,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[int]:
        return await self.invoke(
            "get_pixel",
            [scval.to_uint32(x), scval.to_uint32(y)],
            parse_result_xdr_fn=lambda v: scval.from_uint32(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def get_canvas(
        self,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[bytes]:
        return await self.invoke(
            "get_canvas",
            [],
            parse_result_xdr_fn=lambda v: scval.from_bytes(v),
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def get_pixels(
        self,
        coords: List[Tuple[int, int]],
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[List[int]]:
        return await self.invoke(
            "get_pixels",
            [
                scval.to_vec(
                    [
                        scval.to_tuple_struct(
                            [scval.to_uint32(e[0]), scval.to_uint32(e[1])]
                        )
                        for e in coords
                    ]
                )
            ],
            parse_result_xdr_fn=lambda v: [
                scval.from_uint32(e) for e in scval.from_vec(v)
            ],
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )

    async def hello(
        self,
        to: bytes,
        source: Union[str, MuxedAccount] = NULL_ACCOUNT,
        signer: Optional[Keypair] = None,
        base_fee: int = 100,
        transaction_timeout: int = 300,
        submit_timeout: int = 30,
        simulate: bool = True,
        restore: bool = True,
    ) -> AssembledTransactionAsync[List[bytes]]:
        return await self.invoke(
            "hello",
            [scval.to_string(to)],
            parse_result_xdr_fn=lambda v: [
                scval.from_string(e) for e in scval.from_vec(v)
            ],
            source=source,
            signer=signer,
            base_fee=base_fee,
            transaction_timeout=transaction_timeout,
            submit_timeout=submit_timeout,
            simulate=simulate,
            restore=restore,
        )
